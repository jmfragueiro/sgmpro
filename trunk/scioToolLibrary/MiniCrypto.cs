///////////////////////////////////////////////////////////
//  Usuario.cs
//  Implementation of the Class Usuario
//  Generated by Enterprise Architect
//  Created on:      08-abr-2009 11:32:55
//  Original author: Fito
///////////////////////////////////////////////////////////
using System;
using System.Collections;
using System.Security.Cryptography;
using System.Text;
using scioToolLibrary.excepciones;

namespace scioToolLibrary {
    /// <summary>
    /// Esta clase helper se encarga de realizar encriptación de datos
    /// vía un algoritmo DES, simetrico con reutilización de bloque para
    /// lograr un resultado más seguro. La clave secreta y el vector de
    /// inicio estan harcodeados.
    /// </summary>
    public class MiniCrypto {
        private static readonly DESCryptoServiceProvider _DES = new DESCryptoServiceProvider {
            Key = Encoding.ASCII.GetBytes("minichu1"),
            IV = Encoding.ASCII.GetBytes("sciosgmp")
        };

        /// <summary>
        /// Encripta una cadena de texto utilizando el algoritmo DES
        /// (que aqui está implementado para utilizar una semilla de
        /// encriptacion -cadena vector del proceso-, lo que permite 
        /// que el resultado varie entre ejecuciones sobre una misma
        /// cadena). Aqui se utiliza una cadena pasada como argumento
        /// como vector de entrada del proceso de encriptación.
        /// </summary>
        /// <param name="source">
        /// La cadena a encriptarse (máximo de 64 caracteres ascii).
        /// </param>
        /// <param name="iv">
        /// El vector de entrada para el proceso de encriptación.
        /// </param>
        /// <returns>
        /// La cadena resultado del proceso de encriptar el source.
        /// </returns>
        public static string EncriptarConIv(string source, string iv) {
            _DES.IV = Encoding.ASCII.GetBytes(iv);
            return Encriptar(source);
        }

        /// <summary>
        /// Desencripta una cadena de texto utilizando el algoritmo DES
        /// (que aqui está implementado para utilizar una semilla de
        /// encriptacion -cadena vector del proceso-, lo que permite 
        /// que el resultado varie entre ejecuciones sobre una misma
        /// cadena). Aqui se utiliza una cadena pasada como argumento
        /// como vector de entrada del proceso de encriptación.
        /// </summary>
        /// <param name="source">
        /// La cadena a desencriptarse (máximo de 64 caracteres ascii).
        /// </param>
        /// <param name="iv">
        /// El vector de entrada para el proceso de desencriptación.
        /// </param>
        /// <returns>
        /// La cadena resultado del proceso de desencriptar el source.
        /// </returns>
        public static string DesencriptarConIv(string source, string iv) {
            _DES.IV = Encoding.ASCII.GetBytes(iv);
            return Desencriptar(source);
        }

        /// <summary>
        /// Encripta una cadena de texto utilizando el algoritmo DES
        /// (que aqui está implementado para utilizar una semilla de
        /// encriptacion -cadena vector del proceso-, lo que permite 
        /// que el resultado varie entre ejecuciones sobre una misma
        /// cadena). Aqui se utiliza una cadena fija como vector de 
        /// entrada para el proceso de ecriptación (generada al crear
        /// el objeto).
        /// </summary>
        /// <param name="source">
        /// La cadena a encriptarse (máximo de 64 caracteres ascii).
        /// </param>
        /// <returns>
        /// La cadena resultado del proceso de encriptar el source.
        /// </returns>
        public static string Encriptar(string source) {
            byte[] sourceBytes = Encoding.ASCII.GetBytes(source);
            int currentPosition = 0;
            int sourceByteLength = sourceBytes.Length;
            byte[] targetBytes = new byte[64];

            // Create a DES encryptor from this instance to perform encryption.
            CryptoAPITransform ct = (CryptoAPITransform) _DES.CreateEncryptor();

            // Retrieve key handle & set block sizes
            int inputBlockSize = ct.InputBlockSize;

            try {
                if (ct.CanTransformMultipleBlocks) {
                    int numBytesRead;
                    while (sourceByteLength - currentPosition >= inputBlockSize) {
                        numBytesRead = ct.TransformBlock(
                            sourceBytes, currentPosition, inputBlockSize, targetBytes, currentPosition);
                        currentPosition += numBytesRead;
                    }

                    byte[] finalBytes = ct.TransformFinalBlock(
                        sourceBytes, currentPosition, sourceByteLength - currentPosition);
                    finalBytes.CopyTo(targetBytes, currentPosition);
                }
            } catch (Exception e) {
                throw new ScioErrorException("APP-CRYPT-ERROR", e.ToString());
            }

            // Determine if the current transform can be reused & Trim the extra bytes.
            if (!ct.CanReuseTransform)
                ct.Clear();
            return Encoding.ASCII.GetString(TrimArray(targetBytes));
        }

        /// <summary>
        /// Desencripta una cadena de texto utilizando DES.
        /// </summary>
        /// <param name="source">
        /// La cadena argumento del proceso de desencriptación (con un 
        /// máximo de 64 caracteres ascii).
        /// </param>
        /// <returns>
        /// La cadena resultado del proceso de desencriptar el argumento.
        /// </returns>
        public static string Desencriptar(string source) {
            byte[] sourceBytes = Encoding.ASCII.GetBytes(source);
            int currentPosition = 0;
            byte[] targetBytes = new byte[64];

            // Create a DES decryptor from this instance to perform decryption.
            CryptoAPITransform ct = (CryptoAPITransform) _DES.CreateDecryptor();

            // Set block sizes
            int inputBlockSize = ct.InputBlockSize;
            int sourceByteLength = sourceBytes.Length;

            try {
                int numBytesRead;
                while (sourceByteLength - currentPosition >= inputBlockSize) {
                    numBytesRead = ct.TransformBlock(
                        sourceBytes, currentPosition, inputBlockSize, targetBytes, currentPosition);
                    currentPosition += numBytesRead;
                }

                // Transform the final block of bytes.
                byte[] finalBytes = ct.TransformFinalBlock(
                    sourceBytes, currentPosition, sourceByteLength - currentPosition);
                finalBytes.CopyTo(targetBytes, currentPosition);
            } catch (Exception e) {
                throw new ScioErrorException("APP-CRYPT-ERROR", e.ToString());
            }

            // Strip out the second block of bytes & Trim the extra bytes
            Array.Copy(
                targetBytes, (inputBlockSize*2), targetBytes, inputBlockSize, targetBytes.Length - (inputBlockSize*2));
            return Encoding.ASCII.GetString(TrimArray(targetBytes));
        }

        /// <summary>
        /// Resize the dimensions of the array to a size that contains 
        /// only valid data.
        /// </summary>
        /// <param name="targetArray">
        /// Array to be trimmed.
        /// </param>
        /// <returns>
        /// Array trimmed.
        /// </returns>
        private static byte[] TrimArray(byte[] targetArray) {
            IEnumerator enum1 = targetArray.GetEnumerator();
            int i = 0;

            while (enum1.MoveNext()) {
                if (enum1.Current.ToString().Equals("0"))
                    break;
                i++;
            }

            // Create a new array with the number of valid bytes.
            byte[] returnedArray = new byte[i];
            for (int j = 0; j < i; j++)
                returnedArray[j] = targetArray[j];

            return returnedArray;
        }
    }
}