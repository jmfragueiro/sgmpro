///////////////////////////////////////////////////////////
//  IControladorPersistencia.cs
//  Implementation of the Interface IControladorPersistencia
//  Generated by Enterprise Architect
//  Created on:      15-Dic-2009 07:11:10 p.m.
//  Original author: Fito
///////////////////////////////////////////////////////////

using NHibernate;

namespace scioPersistentLibrary.interfases {
    /// <summary>
    /// Esta interfase es la que representa el comportamiento deseable de
    /// una clase que implemente y controle un servicio de persistencia, 
    /// el cual debe encargarse de la persistencia de objetos dentro de
    /// un motor de persistencia. Permite generar una capa de acceso a
    /// datos que abstraiga al sistema de si utiliza un motor de base de
    /// datos directamente ó usa nhibernate ó db4o ó .... En la interfaz 
    /// se establecen además métodos para la gestión de sesiones con el 
    /// servicio de persistencia y las transacciones para así permitir 
    /// transacciones atómicas o complejas.
    /// </summary>
    public interface IControladorPersistencia {
        /// <summary>
        /// Nombre interno del servicio de persistencia (propiedad de solo 
        /// lectura, que se genera desde el servicio al utilizar el método 
        /// crearSSP()).
        /// </summary>
        string Nombre { get; set; }
        /// <summary>
        /// La cadena de conexión al servicio de persistencia (propiedad de 
        /// solo lectura, la que se obtiene desde el servicio al utilizar el 
        /// método crearSSP()).
        /// </summary>
        string CadenaConexion { get; set; }

        /// <summary>
        /// Este método permite establecer una propiedad, al momento de crear 
        /// la clase, de manera de que se utilicen al momento de configurar la
        /// fábrica de sesiones de nhibernate. De esta forma se pueden setear
        /// propiedades en proyectos que utilicen a éste proyecto como referencia.
        /// </summary>
        /// <param name="propiedad">
        /// El nombre del parámetro de NHibernate a setear.
        /// </param>
        /// <param name="valor">
        /// El valor a establecer para el parámetro a setear.
        /// </param>
        void setearPropiedad(string propiedad, string valor);

        /// <summary>
        /// Este método permite incluir una librería, al momento de crear la
        /// clase que implemente la interfaz, de manera de poder agregar mas
        /// de una fuente de definición de modelo al servicio de persistencia.
        /// El cómo deben ser tratadas las 'librerías de definición del modelo'
        /// depende de la implementación de la interfaz, por ejemplo se puede 
        /// agregar la librería scioModeloBase con las definiciones del modelo.
        /// </summary>
        /// <param name="nombreLibreria">
        /// El nombre de la librería de definición (assembly) a incluir en el 
        /// servicio.
        /// </param>
        void incluirLibreria(string nombreLibreria);

        /// <summary>
        /// Este método es el encargado de generar una sesion nueva contra el
        /// sistema de persistencia, terminando primero la actual, si hay una,
        /// y devolveviendo la sesión creada como un object para que pueda ser 
        /// utilizado en la ejecución de las operaciones de persistencia. Este 
        /// método debe relanzar toda excepción como una DBErrorException.
        /// </summary>
        /// <returns>
        /// Un objeto que representa la sesion del sistema de persistencia creado.
        /// </returns>
        ISession crearSsp();

        /// <summary>
        /// Este método es el encargado de devolver la sesion de persistencia
        /// actualmente abierta. Este método relanza toda excepción como una 
        /// DBErrorException.
        /// </summary>
        /// <returns>
        /// Un objeto que representa la sesion en curso (si existe).
        /// </returns>
        ISession getSsp();

        /// <summary>
        /// Este método es el encargado de desconectar la sesión del servicio
        /// de persistencia (podría hacerse, por ejemplo, para así mejorar la 
        /// performance del sistema). Se hacen firmes (commit) todas aquellas
        /// actualizaciones no persistidas. No se podrán ejecutar transacciones 
        /// hasta un nuevo inicio de sesión contra el mecanismo de persistencia.
        /// Si no hay una sesión activa entonces no hace nada. Relanza cualquier
        /// excepcion como una DBErrorException.
        /// </summary>
        void cerrarSsp();

        /// <summary>
        /// Este método es el encargado de terminar una sesión del servicio
        /// de persistencia (esto se debe hacer ante un error fatal ó de bajo
        /// nivel ó que simplemente genere un rollback. Se rollbackean todas 
        /// las actualizaciones pendientes y se pierden las de la memoria, no 
        /// persistidas. Ya no se podrán ejecutar transacciones hasta un nuevo 
        /// inicio de sesión del servicio de persistencia. Si no hay una sesión 
        /// activa entonces no hace nada. Relanza cualquier excepción como una 
        /// DBErrorException. 
        /// </summary>
        void terminarSsp();

        /// <summary>
        /// Este método es el encargado de iniciar una transacción contra el
        /// servicio de persistencia. Como las transacciones dependen siempre
        /// de una sesión ya activa, si no hay una sesión activa entonces se
        /// crea una. Toda operación de persistencia debe generar transacción,
        /// pero si no se creó una previamente se comitea y termina la misma al
        /// terminar la operación (asi se implementa un operación atómica). Se
        /// relanza cualquier excepción como un DBErrorException.
        /// </summary>
        long iniciarTransaccion();

        /// <summary>
        /// Este método determina si existe una transacción en curso actualmente, 
        /// y devuelve un valor booleano declarando dicha situación. 
        /// </summary>
        /// <returns>
        /// Retorna 'true' si existe una transacción en curso ó, si no, 'false'. 
        /// </returns>
        bool hayTransaccion();

        /// <summary>
        /// Este método es el encargado de comitear la transacción actual en
        /// el servicio de persistencia, y luego cierra dicha transacción. No 
        /// se capturan excepciones (si hay) y si no hay transacción se hace
        /// un flush de la sesión (descarga todos los cambios). Si no existe
        /// una sesión entonces no hace nada. No captura excepciones.
        /// </summary>
        /// <param name="scn">
        /// El SCN (system change number) que identifica a la transacción en
        /// curso, si el que se pasa no coincide con el actual, entonces no
        /// se comitea ningun cambio (significa que la transacción es parte
        /// de una mas grande que la contiene).
        /// </param>
        void commitTransaccion(long scn);

        /// <summary>
        /// Este método es el encargado de rollbackear la transacción actual
        /// en el servicio de persistencia, y luego cierra dicha transacción. 
        /// Además se cierra si o si la sesión actual y se pierde el log de 
        /// todos los cambios hechos en memoria. Esto es necesario porque el
        /// NHibernate rollbackea solo la base y por lo tanto quedan los objs
        /// en estado inconsistente en memoria contra lo que hay en la base.
        /// Se relanza cualqueir excepción que se produzca en el medio.
        /// </summary>
        void rollbackTransaccion();

        /// <summary>
        /// Este método realiza un refresh de un objeto contra la base de datos
        /// para asegurarse de que lo que esta viendo es realmente lo ultimisimo.
        /// </summary>
        /// <param name="objeto">
        /// El objeto IEntidadIdentificable cuyos datos quieren actualizarse.
        /// </param>
        void refrescarDatos(IEntidadIdentificable objeto);
    }
}