///////////////////////////////////////////////////////////
//  RepositorioGenerico.cs
//  Implementation of the Class RepositorioGenerico
//  Generated by Enterprise Architect
//  Created on:      08-abr-2009 11:32:53
//  Original author: Fito
///////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using System.Data;
using NHibernate;
using NHibernate.Criterion;
using scioPersistentLibrary.enums;
using scioPersistentLibrary.interfases;
using scioToolLibrary;

namespace scioPersistentLibrary.acceso {
    /// <summary>
    /// En el framework ad-hoc de SCIO, esta clase generica (con parámetros) implementa la 
    /// cabeza de la jerarquía de repositorios de persistencia. Para entender mejor, puede
    /// verse a un repositorio de persistencia como una tabla relacional para una clase de 
    /// objetos particular, en donde cada fila se corresponde entonces con un solo objeto.
    /// Todas las clases que se utilicen con un repositorio deben ser EntidadIdentificada. 
    /// Este nivel en la jerarquía representa un repositorio persistente que solo admitirá 
    /// operaciones de lectura desde el motor de persistencia (pej: una base de datos). La 
    /// presente implementación se basa en utilización de un mecanismo ORM de persistencia 
    /// (NHibernate, configurado vía archivo hibernate.cfg.xml) y acepta la consulta de los 
    /// objetos vía la interfaz Criteria -métodos Get...() que devuelven IList-, ó vía SQL
    /// directo -métodos Select...() que devuelven DataTable- (para lo cual cada campo en 
    /// la BD deberá tener un nombre basado en el formato "PREFIJO_NOMBREATRIBUTODECLASE" 
    /// -donde el prefijo lo da el método GetSelectPrefix de la clase y la lista de campos 
    /// hasta antes del where los da el método GetSelectString de la clase). La clase usa
    /// a la clase 'Persistencia' que gestiona la sesion de persistencia para cada acción.
    /// </summary>
    public class RepositorioGenerico<T> where T : EntidadIdentificada<T> {
        /// <summary>
        /// Este metodo devuelve un único objeto persistido del tipo T a 
        /// partir de su ID interno (asignado desde EntidadIdentificada).
        /// Este método (su ejecución y performance) es equivalente para
        /// el esquema objeto y para el esquema relacional.
        /// </summary>
        /// <param name="id">
        /// El ID interno del objeto (registro) de tipo T deseado.
        /// </param>
        /// <returns>
        /// El objeto de tipo T que cuyo ID coincide con el pasado.
        /// </returns>
        public static T GetById(Guid id) {
            return Persistencia.Controlador.getSsp().Get<T>(id);
        }

        #region CriteriaNH
        /// <summary>
        /// Este metodo devuelve todos los objetos persistidos del tipo T
        /// sin imprtar su estado de vida basado en el atributo FechaBaja.
        /// </summary>
        /// <returns>
        /// La colección de objeto de tipo T obtenidos (sin filtros).
        /// </returns>
        public static IList<T> GetAll() {
            return ConstruirConsultaNH(false, null, null).List<T>();
        }

        /// <summary>
        /// Este método devuelve todos los objetos persistidos del tipo T
        /// que se encuentren 'vivos'. El significado de 'vivo' respeta la
        /// implementación en EntidadIdentificada (FechaBaja==Fechas.FechaNull).
        /// </summary>
        /// <returns>
        /// La colección de objetos vivos de tipo T obtenidos (sin filtros).
        /// </returns>
        public static IList<T> GetAliveAll() {
            return ConstruirConsultaNH(true, null, null).List<T>();
        }

        /// <summary>
        /// Este método devuelve una lista de objetos persistido que cumplen 
        /// con los criterios pasados como argumento y en el orden establecido.
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param>  
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <param name="orden">
        /// La lista de criterios de Orden a utilizarse como orden del listado.
        /// </param>
        /// <returns>
        /// La lista de objetos que coincide con el criterio pasado y según el
        /// orden establecido.
        /// </returns>
        public static IList<T> GetByCriteria(
            bool alive, IEnumerable<ICriterioConsulta> criterios, IEnumerable<IOrdenConsulta> orden) {
            return ConstruirConsultaNH(alive, criterios, orden).List<T>();
        }

        /// <summary>
        /// Este método devuelve un único objeto persistido que cumple con los 
        /// criterios pasados como argumento (el cual debe decantar en un solo 
        /// objeto como resultado).
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param>  
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <returns>
        /// El objeto que coincide con el criterio pasado.
        /// </returns>
        public static T GetUniqueByCriteria(
            bool alive, IEnumerable<ICriterioConsulta> criterios) {
            return ConstruirConsultaNH(alive, criterios, null).UniqueResult<T>();
        }

        /// <summary>
        /// Este metodo se encarga de ejecutar una consulta de proyección 
        /// (función agregación en relacional) sobre una clase perisitda 
        /// dentro del repositorio. La proyección debería devolver un
        /// valor numérico siempre ya que su resultado es tomado como un
        /// double (sino podría ser transformado o lanzar una excepción).
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param>  
        /// <param name="funcion">
        /// La proyección (función de agregación) a ejecutarse.
        /// </param>
        /// <param name="atributo">
        /// El parámetro sobre el cual se ejecuta la proyección.
        /// </param>
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <returns>
        /// El valor (double) calculado por la consulta de agregación ejecutada.
        /// </returns>
        public static double GetAggByCriteria(
            bool alive,
            EFuncionAgregacion funcion,
            string atributo,
            IEnumerable<ICriterioConsulta> criterios) {
            switch (funcion) {
                case EFuncionAgregacion.COUNT:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.Count(atributo)).
                                UniqueResult());
                case EFuncionAgregacion.SUMA:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.Sum(atributo)).
                                UniqueResult());
                case EFuncionAgregacion.PROMEDIO:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.Avg(atributo)).
                                UniqueResult());
                case EFuncionAgregacion.MAXIMO:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.Max(atributo)).
                                UniqueResult());
                case EFuncionAgregacion.MINIMO:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.Min(atributo)).
                                UniqueResult());
                case EFuncionAgregacion.COUNT_DISTINCT:
                    return
                        Convert.ToDouble(
                            ConstruirConsultaNH(alive, criterios, null).
                            SetProjection(Projections.CountDistinct(atributo))
                                .UniqueResult());
                default:
                    return 0;
            }
        }
        #endregion CriteriaNH

        #region SQL
        /// <summary>
        /// Este método ejecuta una consulta relacional directa (select) 
        /// y sin filtros sobre una tabla, que contiene un repositorio 
        /// persistente, y devuelve una Tabla (DataTable) con todas las 
        /// filas obtenidas desde esta donde cada fila representaría, y 
        /// por ello permitiría armar, a un objeto del tipo de la clase 
        /// que se contiene en ese repositorio. No se tiene en cuenta el
        /// estado de vida de los objetos.
        /// </summary>
        /// <returns>
        /// La tabla con todas las filas obtenidas desde la consulta.
        /// </returns>
        public static DataTable SelectAll() {
            return Persistencia.EjecutarSqlSelect(
                ConstruirConsultaSQL(false, null, null), Persistencia.Controlador.CadenaConexion);
        }

        /// <summary>
        /// Este método ejecuta una consulta relacional directa (select) 
        /// sobre una tabla, que contiene un repositorio persistente, y 
        /// devuelve una Tabla (DataTable) con todas las filas obtenidas 
        /// con el único filtro de ver si estan 'vivas' (es decir ver si
        /// FechaBaja = '1753-01-01 00:00:000'). Aquí cada fila representa, 
        /// y por ello permite armar, un objeto del tipo de la clase que 
        /// se contiene en ese repositorio. 
        /// </summary>
        /// <returns>
        /// Una tabla con todos las filas de objetos vivos obtenidos.
        /// </returns>
        public static DataTable SelectAliveAll() {
            return Persistencia.EjecutarSqlSelect(
                ConstruirConsultaSQL(true, null, null), Persistencia.Controlador.CadenaConexion);
        }

        /// <summary>
        /// Este método ejecuta una consulta relacional directa (select) 
        /// sobre una tabla, que contiene un repositorio persistente, y 
        /// devuelve una Tabla (DataTable) con todas las filas obtenidas 
        /// a partir del filtro que se pasa como argumento y en el orden
        /// que se establece. Aquí cada fila representa, y por ello permite 
        /// armar, un objeto del tipo de la clase que se contiene en ese 
        /// repositorio. 
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente las filas de los objetos vivos 
        /// (es decir donde FechaBaja = '1753-01-01 00:00:000'), ó todas 
        /// las filas.
        /// </param>  
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <param name="orden">
        /// La lista de criterios de Orden a utilizarse como orden del listado.
        /// </param>
        /// <returns>
        /// La tabla con todas las filas obtenidas desde la consulta.
        /// </returns>
        public static DataTable SelectByCriteria(
            bool alive,
            IEnumerable<ICriterioConsulta> criterios,
            IEnumerable<IOrdenConsulta> orden) {
            return Persistencia.EjecutarSqlSelect(
                ConstruirConsultaSQL(alive, criterios, orden),
                Persistencia.Controlador.CadenaConexion);
        }

        /// <summary>
        /// Este método ejecuta una consulta relacional directa (select) y 
        /// devuelve un único objeto, del tipo de la entidad consultada, el
        /// cual se obtiene a partir de una única (ó la primer) fila traida
        /// en base a criterios pasados como argumento (que entonces deben 
        /// decantar en una sola fila como resultado o se toma solamente la 
        /// primera de las obtenidas).
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente las filas de los objetos vivos 
        /// (es decir donde FechaBaja = '1753-01-01 00:00:000'), ó todas 
        /// las filas.
        /// </param>  
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <returns>
        /// El objeto armado desde la fila obtenida con el criterio pasado.
        /// </returns>
        public static T SelectUniqueByCriteria(
            bool alive, IEnumerable<ICriterioConsulta> criterios) {
            return CollectionHelper.CreateItem<T>(
                Persistencia.EjecutarSqlSelect(
                    ConstruirConsultaSQL(alive, criterios, null),
                    Persistencia.Controlador.CadenaConexion).Rows[0]);
        }

        /// <summary>
        /// Este metodo se encarga de construir una consulta relacional
        /// (select) de agregación sobre una entidad del repositorio, de 
        /// acuerdo a las propias características propias del mecanismo 
        /// de persistencia usado y en base a los filtros y condiciones 
        /// de orden pasados. La consulta de agregación debe devolver un
        /// valor numérico siempre ya que su resultado es tomado como un
        /// double (sino podría ser transformado o lanzar una excepción).
        /// 
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param> 
        /// <param name="funcion">
        /// La función de agregación a ejecutarse.
        /// </param>
        /// <param name="atributo">
        /// El parametro sobre el cual se ejecuta la función de agregación.
        /// </param>
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <returns>
        /// El valor (double) calculado por la consulta.
        /// </returns>
        public static double SelectAggByCriteria(
            bool alive,
            EFuncionAgregacion funcion,
            string atributo,
            IEnumerable<ICriterioConsulta> criterios) {
            string select, pre = EsquemaRelacional.GetPrefijo(typeof(T).Name);
            switch (funcion) {
                case EFuncionAgregacion.COUNT:
                    select = string.Format("count({0}_{1})", pre, atributo);
                    break;
                case EFuncionAgregacion.SUMA:
                    select = string.Format("sum({0}_{1})", pre, atributo);
                    break;
                case EFuncionAgregacion.PROMEDIO:
                    select = string.Format("avg({0}_{1})", pre, atributo);
                    break;
                case EFuncionAgregacion.MAXIMO:
                    select = string.Format("max({0}_{1})", pre, atributo);
                    break;
                case EFuncionAgregacion.MINIMO:
                    select = string.Format("min({0}_{1})", pre, atributo);
                    break;
                case EFuncionAgregacion.COUNT_DISTINCT:
                    select = string.Format("count(distinct({0}_{1}))", pre, atributo);
                    break;
                default:
                    return 0;
            }
            return Convert.ToDouble(
                Persistencia.EjecutarSqlSelect(
                    string.Format("select isnull({0},0) as resultado from {1} where {2}",
                        select,
                        typeof(T).Name,
                        ConstruirWhereSQL(alive, criterios, null)),
                        Persistencia.Controlador.CadenaConexion).Rows[0]["resultado"]);
        }
        #endregion SQL

        #region helpers
        /// <summary>
        /// Este metodo se encarga de construir una consulta contra el 
        /// repositorio, de acuerdo a las características propias del
        /// mecanismo de persistencia utilizado y en base a los filtros
        /// y condiciones de orden pasados como argumento.
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param> 
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <param name="orden">
        /// La lista de criterios de Orden a utilizarse como orden del listado.
        /// </param>
        /// <returns>
        /// La consulta armada y lista para su ejecución.
        /// </returns>
        private static ICriteria ConstruirConsultaNH(
            bool alive, IEnumerable<ICriterioConsulta> criterios, IEnumerable<IOrdenConsulta> orden) {
            ICriteria sql = Persistencia.Controlador.getSsp().CreateCriteria(typeof(T));

            if (criterios != null)
                foreach (ICriterioConsulta criterio in criterios)
                    sql.Add(criterio.getCriterioNH());

            if (alive)
                sql.Add(Restrictions.Eq("FechaBaja", Fechas.FechaNull));

            if (orden != null)
                foreach (IOrdenConsulta ord in orden)
                    sql.AddOrder(ord.getOrdenNH());

            return sql;
        }

        /// <summary>
        /// Este metodo se encarga de construir una consulta contra el 
        /// repositorio, de acuerdo a las características propias del
        /// mecanismo de persistencia utilizado y en base a los filtros
        /// y condiciones de orden pasados como argumento.
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param> 
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <param name="orden">
        /// La lista de criterios de Orden a utilizarse como orden del listado.
        /// </param>
        /// <returns>
        /// La consulta armada y lista para su ejecución.
        /// </returns>
        private static string ConstruirConsultaSQL(
            bool alive, IEnumerable<ICriterioConsulta> criterios, IEnumerable<IOrdenConsulta> orden) {
            return string.Format("{0} {1}",
                EsquemaRelacional.GetSelectString(typeof(T).Name),
                ConstruirWhereSQL(alive, criterios, orden));
        }

        /// <summary>
        /// Este método se encarga de generar la porción WHERE de una cadena 
        /// de consulta SQL estableciendo de acuerdo a los parametros pasados
        /// y sin incluir la palabra clave WHERE.
        /// </summary>
        /// <param name="alive">
        /// Si debe contemplar solamente objetos vivos o todos (también 
        /// los dados de baja).
        /// </param> 
        /// <param name="criterios">
        /// La lista de criterios de filtro (string, object) a aplicarse.
        /// </param>
        /// <param name="orden">
        /// La lista de criterios de Orden a utilizarse como orden del listado.
        /// </param>
        /// <returns>
        /// El Where de una consulta armado y listo para su ejecución (sin 
        /// la palabra clave WHERE).
        /// </returns>
        private static string ConstruirWhereSQL(
            bool alive, IEnumerable<ICriterioConsulta> criterios, IEnumerable<IOrdenConsulta> orden) {
            string where = "1 = 1";
            string orderby = null;
            string pre = EsquemaRelacional.GetPrefijo(typeof(T).Name);

            if (criterios != null)
                foreach (ICriterioConsulta criterio in criterios)
                    where = string.Format("( {0} ) and {1}", where, criterio.getCriterioSQL(pre));

            if (alive)
                where = string.Format("( {0} ) and {1}_FechaBaja = '{2}'", where, pre, Fechas.FechaNull);

            if (orden != null)
                foreach (IOrdenConsulta ord in orden)
                    orderby = (orderby == null)
                                  ? ord.getOrdenSQL(pre)
                                  : string.Format("{0}, {1}", orderby, ord.getOrdenSQL(pre));

            return (orderby == null)
                       ? where
                       : string.Format("{0} order by {1}", where, orderby);
        }
        #endregion helpers
    }
}