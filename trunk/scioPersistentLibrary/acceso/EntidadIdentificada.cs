///////////////////////////////////////////////////////////
//  EntidadIdentificada.cs
//  Implementation of the Class EntidadIdentificada
//  Generated by Enterprise Architect
//  Created on:      08-abr-2009 11:32:53
//  Original author: Fito
///////////////////////////////////////////////////////////
using System;
using scioPersistentLibrary.interfases;
using scioToolLibrary;

namespace scioPersistentLibrary.acceso {
    /// <summary>
    /// Esta clase representa a una entidad del dominio del sistema que puede
    /// persistir y utilizarse dentro del framework de SCIO. Así, toda clase
    /// persistente debe heredar de esta clase base, la que le incluye algunas
    /// características base esperadas por el framwork, como un identificador, 
    /// asignado por el sistema, para su pk y el trabajo con NHibernate y unos
    /// m;etodos para determinar el estado del objeto (alive=vivo ó dado de baja. 
    /// Las bajas de las entidades identificadas son lógicas, es decir que solo
    /// se asigna una fecha de baja al atributo incluido FechaBaja. Por esto, si 
    /// se utiliza un esquema ORM debe tenerse en cuenta de mapear, en cada una 
    /// de las subclases de EntidadIdentifiada, un campo para el atributo "Id" y 
    /// un campo para el atributo "FechaBaja". Esta clase también se encarga de
    /// manejar la comparación vía Equal y de mantenerl la identidad a lo largo 
    /// del código del sistema. Todas las clases que serán persistidas deberían 
    /// heredar de ésta.
    /// </summary>
    public class EntidadIdentificada<T> : IEntidadIdentificable where T : EntidadIdentificada<T> {
        /// <summary>
        /// ID de la base de datos, generado por NHibernate.
        /// </summary>
        public virtual Guid Id {
            get { return _id; }
            set { _id = value;
                _isNew = false;}
        }
        private Guid _id;
        /// <summary>
        /// Este atributo es un flag que indica si el objeto ha sido
        /// recientemente creado y aún no se ha marcado para persistir
        /// (por lo que todavía no posee un Id propio).
        /// </summary>
        private bool _isNew;
        /// <summary>
        /// La fecha de baja de la entidad (si permite baja física 
        /// entonces no deberia tomarse en cuenta aunque persista).
        /// </summary>                
        public virtual DateTime FechaBaja {
            get { return _fechabaja; }
            set { _fechabaja = Fechas.GetOkDate(value); }
        }
        private DateTime _fechabaja = Fechas.FechaNull;

        /// <summary>
        /// Contructor de la clase que inicializa el Id al crear el objeto.
        /// </summary>
        public EntidadIdentificada() {
            _id = Guid.NewGuid();
            _isNew = true;
        }

        /// <summary>
        /// Este método sobreescribe al Equals de la clase object para
        /// establecer que dos objetos de esta clase son iguales entre 
        /// sí solo si son iguales los Id's (son únicos) de los mismos.
        /// </summary>
        /// <param name="obj">
        /// El objeto a comparar con el que recibe la llamada.
        /// </param>
        /// <returns>
        /// Retorna 'true' si establece que son iguales o si no 'false'.
        /// </returns>
        public override bool Equals(object obj) {
            if (obj == null || !(obj is T))
                return false;

            if (this == obj)
                return true;

            T comparando = obj as T;
            return Id.Equals(comparando.Id);
        }

        /// <summary>
        /// Este método genera un valor unico (hash) para cada Permiso, y debe
        /// estar aquí porque sobreescribimos tb el método Equals de object 
        /// (compone el valor unico como el hascode del string fomrmado por la
        /// clave del recurso mas el toString del Tipo de permiso).
        /// </summary>
        /// <returns>
        /// Un valor unico (hash) para el permiso.
        /// </returns>
        public override int GetHashCode() {
            return Id.GetHashCode();
        }

        /// <summary>
        /// Este método hace persistente el objeto en cuestión si es nuevo 
        /// ó hace persistente las modificaciones si no lo es, verificando 
        /// si debe comitear (depende de si el servicio de persistencia ya
        /// posee una transacción en curso -no comitea- ó si no la hay -si
        /// comitea-).
        /// </summary>
        public virtual void save() {
            if (_isNew)
                RepositorioPersistente<T>.Add((T)this);
            else
                RepositorioPersistente<T>.Update((T)this);
            _isNew = false;
        }

        /// <summary>
        /// Este método deshace la persistencia del objeto en cuestion,
        /// verificando si debe comitear (depende de si el servicio de 
        /// persistencia ya posee una transacción en curso -no comitea- 
        /// ó si no la hay -si comitea-). El delete no borra físicamente 
        /// el objeto en el servicio -por ejemplo: el registro en la base 
        /// de datos- sino simplemente asigna el atributo fecha de baja, 
        /// incluído por ésta clase a todas sus subclases. Por esto, 
        /// para borrar físicamente hay que usar un método sobrepasado en 
        /// la subclase que lo desee.
        /// </summary>
        public virtual void delete() {
            if (!isAlive())
                return;

            FechaBaja = DateTime.Now;
            save();
        }

        /// <summary>
        /// Este método rehace la persistencia del objeto en cuestion,
        /// verificando si debe comitear (depende de si el servicio de 
        /// persistencia ya posee una transacción en curso -no comitea- 
        /// ó si no la hay -si comitea-). El undelete aprovecha el hecho 
        /// de que el delete no borra físicamente el objeto y asigna el 
        /// atributo fecha de baja como nulo.
        /// </summary>
        public virtual void undelete() {
            if (isAlive())
                return;

            FechaBaja = Fechas.FechaNull;
            save();
        }

        /// <summary>
        /// Este método es el encargado de anunciar si el objeto en 
        /// cuestión se enceuntra 'vivo' o nó, sea lo que fuere que 
        /// eso signifique. Permite establecer un patrón común para 
        /// determinar, por ejemlo, objetos dados de baja. 
        /// </summary>
        /// <returns>
        /// Retorna 'true' si el objeto está 'vivo', lo que aquí quiere
        /// decir que el objeto tiene fecha de baja = null (es el retorno 
        /// por defecto si no se sobrepasa en la subclase), ó, si no, se 
        /// retorna 'false'.
        /// </returns>
        public virtual bool isAlive() {
            return (_fechabaja == Fechas.FechaNull);
        }

        /// <summary>
        /// Este método refresca el presente objeto (es decir actualiza 
        /// sus datos) desde el motor de persistencia utilizado para 
        /// persistirlo.
        /// </summary>
        /// <returns>
        /// El presente objeto con sus datos actualizados.
        /// </returns>
        public virtual T refrescar() {
            if (!_isNew)
                Persistencia.Controlador.refrescarDatos(this);
            return (T)this;
        }
    }
}