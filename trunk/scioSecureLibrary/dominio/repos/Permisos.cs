///////////////////////////////////////////////////////////
//  Permisos.cs
//  Implementation of the Class Permisos
//  Generated by Enterprise Architect
//  Created on:      13-abr-2009 17:23:42
//  Original author: Fito
///////////////////////////////////////////////////////////
using System.Collections.Generic;
using scioParamLibrary.dominio;
using scioPersistentLibrary.acceso;
using scioPersistentLibrary.criterios;
using scioSecureLibrary.enums;

namespace scioSecureLibrary.dominio.repos {
    /// <summary>
    /// Esta clase representa al Repositorio de persistencia
    /// de Nhibernate para la entidad Sesion del sistema.
    /// </summary>
    public class Permisos : RepositorioPersistente<Permiso> {
        /// <summary>
        /// Este método devuelve un objeto Permiso para un recurso
        /// determinado y de un tipo deseado, siempre y cuando este
        /// exista en la base.
        /// </summary>
        /// <param name="recurso">
        /// El recurso para el cual se verifica el permiso.
        /// </param>
        /// <param name="tipo">
        /// El tipo de permiso verificado.
        /// </param> 
        /// <returns>
        /// EL objeto Permiso del tipo deseado para el recurso deseado.
        /// </returns>
        public static Permiso GetByRecursoTipo(Parametro recurso, ETipoPermiso tipo) {
            return GetUniqueByCriteria(true, new[] {Criterios.Igual("Recurso", recurso), Criterios.Igual("Tipo", tipo)});
        }

        /// <summary>
        /// Este método ordena un conjunto de Permisos según su 
        /// nombre en forma ascendente (primero los mas viejos).
        /// </summary>
        /// <param name="origen">
        /// El conjunto de Permisos a ordenar.
        /// </param>
        /// <returns>
        /// El conjunto de Permisos ordenado por fecha (ascendente).
        /// </returns>
        public static IList<Permiso> OrdenarPorNombre(IList<Permiso> origen) {
            Permiso temp = new Permiso();
            IList<Permiso> conjunto = new List<Permiso>();

            while (conjunto.Count < origen.Count) {
                string piso = "ZZZZZZ";
                foreach (Permiso obj in origen)
                    if (!conjunto.Contains(obj))
                        if (obj.ToString().CompareTo(piso) <= 0) {
                            piso = obj.ToString();
                            temp = obj;
                        }
                conjunto.Add(temp);
            }

            return conjunto;
        }
    }
}