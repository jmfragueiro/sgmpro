///////////////////////////////////////////////////////////
//  SecureService.cs
//  Implementation of the Class SecureService
//  Generated by Enterprise Architect
//  Created on:      13-abr-2009 17:44:30
//  Original author: Fito
///////////////////////////////////////////////////////////
using System;
using scioSecureLibrary.dominio;
using scioSecureLibrary.enums;
using scioSecureLibrary.excepciones;
using scioSecureLibrary.interfases;

namespace scioSecureLibrary {
    /// <summary>
    /// Esta es una clase que implementa un servicio de seguridad completo
    /// para un sistem. Se implementa la Interface IControladorSeguridad, y
    /// provee servicios para el manejo de usuarios, sesiones, roles y perfiles.
    /// </summary>
    public sealed class SecureService : IControladorSeguridad {
        private static Sesion _sesion;

        /// <summary>
        /// Este método inicia una sesión de usuario dentro del sistema
        /// (para lo cual crea el objeto Sesion si debe) a partir de los 
        /// datos de conexión pasados. Lanza una SecurityErrorException si 
        /// no puede iniciar la sesión o una SesionErrorException si ya 
        /// hay una sesion activa.
        /// </summary>
        /// <param name="user">
        /// El nombre del usuario que intenta el inicio de sesión.
        /// </param>
        /// <param name="pass">
        /// La contraseña del usuario que intenta el inicio de sesión.
        /// </param>
        public void iniciarSesion(string user, string pass) {
            if (_sesion != null)
                throw new SesionErrorException("SESION-EXISTS", _sesion.ToString());

            try {
                _sesion = new Sesion();
                _sesion.logon(user, pass);
            } catch (Exception e) {
                _sesion = null;
                throw new SesionErrorException("SESION-INIT-ERROR", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve el nombre del usuario de la sesión actual
        /// del sistema. 
        /// </summary>
        /// <returns>
        /// Retorna el nombre del usuario de la sesión actual o 'NINGUNO'.
        /// </returns>
        public Usuario getUsuario() {
            if (_sesion == null)
                throw new SesionErrorException("SESION-NOEXISTS");

            return _sesion.Usuario;
        }

        /// <summary>
        /// Este método establece si existe una sesión activa actualmente
        /// dentro del sistema.
        /// </summary>
        /// <returns>
        /// Retorna 'true' si existe una sesion activa, o si no 'false'
        /// </returns>
        public bool haySesionActiva() {
            return (_sesion != null);
        }

        /// <summary>
        /// Este método devuelve el nombre del usuario de la sesión actual
        /// del sistema. 
        /// </summary>
        /// <returns>
        /// Retorna el nombre del usuario de la sesión actual o 'NINGUNO'.
        /// </returns>
        public Sesion getSesion() {
            if (_sesion == null)
                throw new SesionErrorException("SESION-NOEXISTS");

            return _sesion;
        }

        /// <summary>
        /// Este método cierra la sesión de usuario actual del sistema 
        /// Si no hay una sesión creada o activa, solo logea un mensaje
        /// ó, si no puede cerrar la sesión, lanza SesionErrorException.
        /// </summary>
        public void terminarSesion() {
            try {
                if (_sesion == null)
                    throw new SesionErrorException("SESION-NOEXISTS");

                _sesion.logoff();
                _sesion = null;
            } catch (Exception e) {
                throw new SesionErrorException("SESION-ERROR", e.ToString());
            }
        }

        /// <summary>
        /// Este método verifica si el usuario actualmente conectado posee un 
        /// permiso determinado. Lanza una SecurityErrorException si no consigue 
        /// determinar un recurso válido a partir de la cadena pasada como argumento.
        /// </summary>
        /// <param name="recurso">
        /// La cadena con la que se establece el recurso a verificar.
        /// </param>
        /// <param name="tipo">
        /// El tipo de permiso a verificar para el recurso determinado.
        /// </param>
        /// <returns>
        /// Retorna 'true' si el usuario posee el permiso o si no 'false'.
        /// </returns>
        public bool usuarioActualPoseePermiso(string recurso, ETipoPermiso tipo) {
            return usuarioPoseePermiso(getUsuario(), recurso, tipo);
        }

        /// <summary>
        /// Este método verifica si un usuario cualquiera posee un permiso 
        /// determinado. Lanza una SecurityErrorException si no consigue 
        /// determinar un recurso válido a partir de la cadena pasada como 
        /// argumento.
        /// </summary>
        /// <param name="usuario">
        /// El usuario del que se desea verificar el permiso.
        /// </param>
        /// <param name="recurso">
        /// La cadena con la que se establece el recurso a verificar.
        /// </param>
        /// <param name="tipo">
        /// El tipo de permiso a verificar para el recurso determinado.
        /// </param>
        /// <returns>
        /// Retorna 'true' si el usuario posee el permiso o si no 'false'.
        /// </returns>
        public bool usuarioPoseePermiso(Usuario usuario, string recurso, ETipoPermiso tipo) {
            return usuario.poseePermiso(recurso, tipo);
        }
    }
}