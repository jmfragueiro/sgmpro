///////////////////////////////////////////////////////////
//  CUCaller.cs
//  Implementation of the Class CUCaller encargada del
//  llamado a casos de uso genericos ubicados en otros
//  assemblies.
//  Generated by Fito
//  Created on:      13-abr-2009 17:23:41
//  Original author: Fito
///////////////////////////////////////////////////////////
using System;
using System.Reflection;
using scioBaseLibrary.excepciones;
using scioBaseLibrary.interfases;
using scioToolLibrary.enums;

namespace scioBaseLibrary.helpers {
    /// <summary>
    /// Esta clase en la encargada de ejeuctar las operación del llamado a 
    /// controladores de casos de uso externos genéricos, esto quiere decir 
    /// casos de uso implementados en otro proyecto, y que se generan como 
    /// una DLL separada. El protocolo es:
    /// 1-La DLL que contiene al controlador del CU debe estar dentro del mismo 
    /// directorio que la aplicación que la llama. Esta DLL se genera desde el
    /// proyecto de VS que contiene a la clase controladora del CU.
    /// 2-La DLL, y por lo tanto el proyecto -comúnmente-, debe llamarse como CU 
    /// con 'cu' (en min.) adelante. Este nombre debe pasarse en el argumeto uc 
    /// de CallCU. Por ejemplo:cuAbmUsuario debe ser la DLL (por ello el nombre 
    /// del proyecto en VS) para el controlador del caso de uso CUAbmUsuario. 
    /// 3-Si el caso de uso es el principal dentro del proyecto, la clase que lo
    /// controla, y que se instancia vía reflexión, debe implementar la interfaz
    /// IControladorCasoUso y debe llamarse como el CU con 'CU' (en mayúsculas). 
    /// Por ejemplo: CUAbmUsuario en el proyecto cuAbmUsuario.
    /// 4-Si el CU NO es el principal dentro del proyecto, entonces el argumento
    /// uc debe venir como nombreDelProyecto.nombreDelCU. Por ejemplo: puede ser
    /// cuAbmUsuario.CUAsignarUsuario para un caso de uso extra Asignar Usuario
    /// que se incluye dentro del proyecto cuAbmUsuario.   
    /// 5-La clase controladora debe implementar la interfaz IControladoCasoUso.
    /// </summary>
    public class CUCaller {
        /// <summary>
        /// Este método es el encargado de ejeuctar los casos de uso
        /// externos genéricos vía un proceso de reflexión que termina
        /// llamando al método iniciar() de la clase asociada. En esta
        /// versión, la clase de caso de uso se debe llamara igual que
        /// la dll dentro de la que se encuentra, pero con CU en (may.)
        /// en su nombre en lugar de cu (min.) de la dll.
        /// </summary>
        /// <param name="uc">
        /// El nombre de la dll sin extensión (se usa para obtener el de 
        /// la clase).
        /// </param>
        /// <param name="padre">
        /// Un objeto que será pasado como el argumento 'padre' del caso 
        /// de uso al método iniciar() del objeto creado.
        /// </param>
        /// <param name="pars">
        /// Un arreglo de cadenas que será pasado como el argumento 'valor'
        /// del caso de uso al método iniciar() del objeto creado.
        /// </param>
        public static IControladorCasoUso CallCU(string uc, object padre, params object[] pars) {
            Sistema.Controlador.logear("UCCALLER", ENivelMensaje.INFORMACION, uc);
            if (uc != null && uc.StartsWith("cu"))
                try {
                    // Luego obtiene el Assembly a partir del
                    // nombre del caso de uso seteado en el objeto                    
                    string asembly = (uc.Contains(".")
                        ? uc.Split('.')[0]
                        : uc) + ".dll";                    
                    Assembly asm = Assembly.LoadFrom(Sistema.Controlador.AppPath + "\\" + asembly);

                    // Luego obtiene el nombre completo de la clase
                    string clase = uc.Contains(".")
                        ? uc
                        : (uc + "." + uc.Replace("cu", "CU"));
                    Type ty = asm.GetType(clase);

                    // Luego obtiene un constructor para generar
                    // el objeto que será el destino de la llamada
                    ConstructorInfo[] ci = ty.GetConstructors();
                    object objo = ci[0].Invoke(null);
                    IControladorCasoUso objoCu = (IControladorCasoUso)objo;

                    // Luego arma el arreglo de parametros para
                    // el caso de uso (siempre primero va el padre)
                    object[] parametros = new[] {
                        padre, pars
                    };

                    // Finalmente se realiza la llamada sobre el
                    // objeto recientemente generado via reflexion
                    MethodInfo mti = ty.GetMethod("iniciar");
                    mti.Invoke(objoCu, parametros);

                    return objoCu;
                } catch (Exception e) {
                    throw new CuErrorException("APP-ERROR", e.ToString());
                }

            throw new AppErrorException("UCCALLER-NOK", uc);
        }
    }
}