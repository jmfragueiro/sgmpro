///////////////////////////////////////////////////////////
//  Cuenta.cs
//  Implementation of the Class Cuenta
//  Generated by Enterprise Architect
//  Created on:      20-abr-2009 16:57:17
//  Original author: Fernando
///////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using scioBaseLibrary;
using scioBaseLibrary.excepciones;
using scioParamLibrary.dominio;
using scioParamLibrary.dominio.repos;
using scioPersistentLibrary;
using scioPersistentLibrary.acceso;
using scioSecureLibrary.dominio;
using scioToolLibrary;
using sgmpro.dominio.gestion;
using sgmpro.dominio.gestion.repos;

namespace sgmpro.dominio.configuracion {
    /// <summary>
    /// Esta clase representa a una Cuenta Morosa dentro del sistema. La Cuenta representa
    /// la unidad central para el sistema e involucra a una deuda específica de una Persona 
    /// (titular y quizás con garante) con una Entidad y a través de un Producto específico 
    /// (por ejemplo: crédito prendario). Toda cuenta tiene su lista de instancias de Deuda 
    /// asociada, en la que se cargan deudas de tres tipos: Informada (las que se avisan a
    /// y desde el cliente); No Informada (las internas del estudio que no pasan al cliente)
    /// ; y de Convenio (las deudas que estan asociadas a un convenio asociado a la Cuenta. 
    /// En verdad las deudas de Convenio son propias del Convenio (que tiene su propia lista
    /// de deudas), pero pueden obtenerse a traves de la Cuenta, ya que la misma no puede 
    /// tener mas de un convenio activo a la vez. Una Cuenta tampoco puede (en realidad esto
    /// depende del Valorbool del parametro "GESTION.PERMITECUOTASEXTERNAS") tener mas de una
    /// deuda informada activa a la vez, por lo que la asociación de una deuda de este tipo 
    /// da de baja toda las anteriores (de este tipo). Si pueden tenerse muchas deudas tipo
    /// No Infomadas a la vez y mezcladas con la Informada y con Convenio. Una cuenta tambien
    /// tiene una lista de instancias de gestiones que representan a las tareas de gestiones
    /// que se realizaron sobre la misma. Esta clase es persistente.
    /// </summary>
    public class Cuenta : EntidadIdentificada<Cuenta>, IDisposable {
        private static readonly Parametro _finalizada = Parametros.GetByClave("ESTADOGESTION.FINALIZADA");
        private static readonly Parametro _cancelada = Parametros.GetByClave("ESTADOCUENTA.CANCELACION-TOTAL-DE-DEUDA");
        private static readonly Parametro _acuerdo = Parametros.GetByClave("ESTADOCUENTA.ACUERDO-ADMIN.-POR-ESTUDIO");
        private static readonly Parametro _juicioConve = Parametros.GetByClave("ESTADOCUENTA.JUICIO-CON-CONVENIO");
        private static readonly Parametro _gestion = Parametros.GetByClave("ESTADOCUENTA.CUENTA-EN-GESTION");         

        /// <summary>
        /// La entidad a la que pertenece la cuenta
        /// </summary>
        public virtual Entidad Entidad { get; set; }
        /// <summary>
        /// El Producto asociado (que da origen) a la cuenta. No Nulo. FK.
        /// </summary>
        public virtual Producto Producto { get; set; }
        /// <summary>
        /// Código de la cuenta (utilizado en la aplicación). Unico. No Nulo.
        /// </summary>
        public virtual string Codigo { get; set; }
        /// <summary>
        /// Descripción de la cuenta (utilizado en la aplicación). No Nulo.
        /// </summary>
        public virtual string Descripcion { get; set; }
        /// <summary>
        /// El titular de la cuenta. No Nulo. FK.
        /// </summary>
        public virtual Persona Titular { get; set; }
        /// <summary>
        /// El garante del titular de la cuenta. FK.
        /// </summary>
        public virtual Persona Garante { get; set; }
        /// <summary>
        /// El estado de gestión de la cuenta. No Nulo.
        /// </summary>
        public virtual Parametro Estado { get; set; }
        /// <summary>
        /// El expediente legal (si ya está en ese estado).
        /// </summary>
        public virtual string Expediente { get; set; }
        /// <summary>
        /// La descripción del estado legal (si ya está en ese estado).
        /// </summary>
        public virtual string Legales { get; set; }
        /// <summary>
        /// El usuario gestor asignado a la cuenta. Nulo.
        /// </summary>
        public virtual Usuario Gestor { get; set; }
        /// <summary>
        /// El estado de activación de la cuenta. No Nulo.
        /// </summary>
        public virtual bool Activada { get; set; }
        /// <summary>
        /// La vigencia de la cuenta (en días). No Nulo.
        /// </summary>
        public virtual long Vigencia { get; set; }
        /// <summary>
        /// La lista a la que se encuentra asignada la cuenta (si es 
        /// que está asignada a una, => cuando se gestiona se borra).
        /// </summary>
        public virtual ListaGestion ListaAsignada { get; set; }
        /// <summary>
        /// El convenio que se encuentra activo en este momento.
        /// </summary>
        public virtual Convenio ConvenioActivo { get; set; }
        /// <summary>
        /// La fecha desde cuando es elegible la cuenta.
        /// </summary>                
        public virtual DateTime FechaElegible {
            get { return _fechaelegible; }
            set { _fechaelegible = Fechas.GetOkDate(value); }
        }
        private DateTime _fechaelegible = Fechas.FechaNull;
        /// <summary>
        /// La fecha de alta de la cuenta. No Nulo.
        /// </summary>                
        public virtual DateTime FechaAlta {
            get { return _fechaalta; }
            set { _fechaalta = Fechas.GetOkDate(value); }
        }
        private DateTime _fechaalta = DateTime.Now;
        /// <summary>
        /// La fecha de la última asignacion de la cuenta al estudio. No Nulo.
        /// </summary>                
        public virtual DateTime FechaAsignacion {
            get { return _fechaasigna; }
            set { _fechaasigna = Fechas.GetOkDate(value); }
        }
        private DateTime _fechaasigna = DateTime.Now;
        /// <summary>
        /// Conjunto de deudas asociadas directamente a la cuenta. FK (List). 
        /// </summary>
        public virtual IList<Deuda> Deudas { get; set; }
        /// <summary>
        /// Conjunto de gestiones sobre una cuenta corriente. No Nulo. FK (List).
        /// </summary>
        public virtual IList<Gestion> Gestiones { get; set; }

        /// <summary>
        /// Constructor que instancia los conjuntos de la clase.
        /// </summary>
        public Cuenta() {
            Deudas = new List<Deuda>();
            Gestiones = new List<Gestion>();
        }

        /// <summary>
        /// Este método se encarga de evaluar una cuenta en base a una lista
        /// de estrategias determinada que se pasa como argumento. Es método
        /// estático porque permite acelerar la evaluación si se parte desde
        /// el id de base de datos y no desde el objeto en sí (esto porque el 
        /// metodo se llama muchas veces durante una generación de listas por
        /// ejemplo).
        /// </summary>
        /// <param name="ctaId">
        /// El ID de la cuenta a evaluar.
        /// </param>
        /// <param name="estrategias">
        /// La lista de estrategias por la cual se evaluará a la cuenta.
        /// </param>
        /// <returns>
        /// Retorna verdadero si la cuenta pasa la evaluación o falso si no lo hace.
        /// </returns>
        public static bool Evaluar(Guid ctaId, IList<Estrategia> estrategias) {
            foreach (Estrategia estrategia in estrategias)
                if (estrategia.isAlive() && !estrategia.evaluar(ctaId))
                    return false;
            return true;
        }

        /// <summary>
        /// Este método establece el estado de la cuenta a uno determinado
        /// y guarda en el historico de estados dicho cambio. Puede lanzar 
        /// una DataErrorException si tiene algún problema.
        /// </summary>
        /// <param name="estado">
        /// El nuevo estado para la cuenta.
        /// </param>
        public virtual void setearEstado(Parametro estado) {
            setearEstado(estado, null);
        }

        /// <summary>
        /// Este método establece el estado de la cuenta a uno determinado
        /// y guarda en el historico de estados dicho cambio, agregando un
        /// comentario explicativo dle cambio. Lanza DataErrorException si 
        /// tiene algún problema.
        /// </summary>
        /// <param name="estado">
        /// El nuevo estado para la cuenta.
        /// </param>
        /// <param name="comentario">
        /// El comentario para agregar al cambio de estado.
        /// </param>
        public virtual void setearEstado(Parametro estado, string comentario) {
            if (estado == null)
                throw new DataErrorException("ERROR-ELEMENTO-NULO");
            if (!isAlive())
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", ToString());

            // Solo hace estas verificaciones si la cuenta ya tiene estados 
            // guardados (ya que sino es la primera vez y debe dejar pasar)
            if (Estado != null && EstadosCuenta.GetByCuentaPorFechaDesc(this).Count > 0) {
                if (!Activada)
                    throw new DataErrorException("ERROR-USE-CTA-NOACTIVE", ToString());
                if (estado == Estado)
                    return;
            }

            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                (new EstadoCuenta {
                    Cuenta = this,
                    Estado = estado,
                    FechaInicio = DateTime.Now,
                    Usuario = Sistema.Controlador.SecurityService.getUsuario(),
                    Comentario = comentario
                }).save();
                Estado = estado;
                save();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                refrescar();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método retorna el estado mas reciente almacenado de una cuenta 
        /// la tabla de EstadoCuenta. Si esta no tiene historial, entonces crea 
        /// un EstadoCuenta con el estado actual de la cuenta, y lo guarda y se 
        /// devuelve ese.Si ya tiene un historial devuelve el estado almacenado 
        /// del mismo. En general coincide con el atributo Estado de la cuenta, 
        /// salvo en casos que se modifico en memoria y todavía no fue asentado 
        /// (como desde la pantalla de ABM).
        /// </summary>
        /// <returns>
        /// El parametro que representa al último estado de la cuenta.
        /// </returns>
        public virtual EstadoCuenta getUltimoEstadoCuenta() {
            return getEnesimoEstadoCuenta(0);
        }

        /// <summary>
        /// Este método retorna el enésimo estado de una cuenta almacenado en
        /// la tabla de EstadoCuenta, PERO CONTANDO HACIA ATRAS SEGUN EL LONG
        /// ARGUMENTO y comenzando desde el 0 como el estado mas reciente. Si 
        /// la cuenta no tiene historial, entonces se le crea un EstadoCuenta 
        /// con el estado actual de la cuenta (para que siempre al menos tenga 
        /// uno). Luego, si no existe posición enésima entonces se devuelve nulo.
        /// </summary>
        /// <param name="enesimo">
        /// La posición del estado que se desea obtener.
        /// </param>
        /// <returns>
        /// El parametro que representa al enésimo estado de la cuenta (contando
        /// hacia atras y donde el cero representa al estado mas reciente).
        /// </returns>
        public virtual EstadoCuenta getEnesimoEstadoCuenta(long enesimo) {
            IList<EstadoCuenta> lista = EstadosCuenta.GetByCuentaPorFechaDesc(this);
            if (lista == null || lista.Count == 0)
                setearEstado(Estado);

            long val = 0;
            foreach (EstadoCuenta estadoCuenta in EstadosCuenta.GetByCuentaPorFechaDesc(this)) {
                if (enesimo == val++)
                    return estadoCuenta;
            }

            return null;
        }

        /// <summary>
        /// Este método se utiliza para agregar una deuda a la cuenta. Se verifica
        /// si la deuda es deuda original informada y, si es asi, si en el sistema 
        /// se permiten cuotas en deuda informada, de no ser asi entonces, antes de 
        /// agregar la nueva deuda, se da de baja la anterior original informada.
        /// Se lanza una DataErrorException si tiene algún problema.
        /// </summary>
        /// <param name="deuda">
        /// La deuda a agregarse para la cuenta.
        /// </param>
        public virtual void agregarDeuda(Deuda deuda) {
            if (deuda == null)
                throw new DataErrorException("ERROR-ELEMENTO-NULO");
            if (Deudas.Contains(deuda))
                throw new DataErrorException("ERROR-ELEMENTO-INLIST", deuda.ToString());
            if (deuda.Cuenta != null && !Equals(deuda.Cuenta))
                throw new DataErrorException("ERROR-NOADD-ELEMENTO", deuda.ToString());
            if (!deuda.isAlive())
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", deuda.ToString());
            if (!isAlive() || !Activada)
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", ToString());

            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                // Primero verifica si es informada o no y entonces, si lo es,
                // verifica si debe bajar la deuda informada que ya existe.
                if (deuda.Informada && !Producto.DeudaEnCuotas) 
                    bajarDeudaInformada(deuda);

                // Luego inicializa la deuda
                deuda.inicializar();

                // Luego aplica la deuda a la cuenta y guarda los cambios
                deuda.Cuenta = this;
                Deudas.Add(deuda);
                save();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                refrescar();
                deuda.refrescar();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }

            // Aqui se deberia colocar la Cuenta para ver 
            // si su saldo salio de cero y asi cancelarla.
            try {
                verificarYCancelarReavivar();
            } catch (Exception e) {
                throw new DataErrorException("ERROR-POSPAGO-DEUDA", e.ToString());
            }
        }

        /// <summary>
        /// Este método se utiliza para bajar deuda informada de la cuenta,
        /// lo que podría hacerse si dicha deuda debería ser pisada por una 
        /// versión mas actual. Lanza DataErrorException si tiene problemas.
        /// </summary>
        public virtual void bajarDeudaInformada(Deuda deuda) {
            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                foreach (Deuda dd in getDeudaInformada())
                    dd.delete();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                refrescar();
                foreach (Deuda dd in getDeudaInformada())
                    dd.refrescar();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método cancela toda la deuda de la cuenta con
        /// la aplicación de un pago del tipo quita por deuda.
        /// </summary>
        public virtual void cancelarTodasLasDeudas() {
            if (!isAlive() || !Activada)
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", ToString());

            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                foreach (Deuda deuda in getDeudaTotalActual())
                    if (deuda.Total > 0)
                        deuda.cancelarConQuita();
                save();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                refrescar();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }

            try {
                // Aqui verifica si la cuenta debe pasar a estado cancelado
                verificarYCancelarReavivar();
            } catch (Exception e) {
                throw new DataErrorException("ERROR-POSCANCELTODO-CTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve la deuda 'informada': como la deuda viva no 
        /// cancelada formada por deuda origen, gastos y honors. que ha sido
        /// informada desde un cliente de la gestión o creada como informada. 
        /// (atributo Informada=true). No toma en cuenta la deuda en convenio.
        /// Lanza DataErrorException si tiene algún problema.
        /// </summary>
        /// <returns>
        /// La lista de deudas informadas (sin ordenar) o una vacia si no hay nada. 
        /// </returns>
        public virtual IList<Deuda> getDeudaInformada() {
            try {
                IList<Deuda> lista = new List<Deuda>();
                foreach (Deuda deuda in Deudas) {
                    deuda.refrescar();
                    if (deuda.isAlive() && deuda.Informada
                        && !deuda.estaCancelada() && !deuda.estaEnConvenio())
                        lista.Add(deuda);
                }
                return lista;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve la deuda 'no informada': como la deuda viva no 
        /// cancelada formada por cualquier deuda que no haya sido marcada como 
        /// informada (atributo Informada=false). No toma en cuenta la deuda en 
        /// convenio. Lanza DataErrorException si tiene algún problema.
        /// </summary>
        /// <returns>
        /// La lista de deudas no informadas (sin ordenar) o una vacia si no hay nada. 
        /// </returns>
        public virtual IList<Deuda> getDeudaNoInformada() {
            try {
                IList<Deuda> lista = new List<Deuda>();
                foreach (Deuda deuda in Deudas) {
                    deuda.refrescar();
                    if (deuda.isAlive() && !deuda.Informada
                        && !deuda.estaCancelada() && !deuda.estaEnConvenio())
                        lista.Add(deuda);
                }
                return lista;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve la deuda 'en convenio': como la deuda viva no 
        /// cancelada con etsado EN CONVENIO. Lanza DataErrorException si tiene 
        /// algún problema.
        /// </summary>
        /// <returns>
        /// La lista de deudas informadas (sin ordenar) o una vacia si no hay nada. 
        /// </returns>
        public virtual IList<Deuda> getDeudaEnConvenio() {
            try {
                IList<Deuda> lista = new List<Deuda>();
                foreach (Deuda deuda in Deudas) {
                    deuda.refrescar();
                    if (deuda.isAlive() && !deuda.estaCancelada() && deuda.estaEnConvenio())
                        lista.Add(deuda);
                }
                return lista;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve la deuda 'total actual': como la deuda no cancelada
        /// viva formada por todos los tipos de deuda, con la siguiente salvedad: si 
        /// hay convenio activo entonces se trae (en este orden): a) deuda pendiente 
        /// del convenio, b) la deuda no informada; pero si no hay un convenio activo, 
        /// se trae (en este orden) a) la deuda informada, b) la deuda no informada. 
        /// Se puede decir que trae cualquier deuda suceptible de pago. Se lanza una
        /// DataErrorException si tiene algún problema.
        /// </summary>
        /// <returns>
        /// La lista de deuda total actual (sin ordenar) o una vacia si no hay nada. 
        /// </returns>
        public virtual IList<Deuda> getDeudaTotalActual() {
            try {
                IList<Deuda> lista = new List<Deuda>();

                if (ConvenioActivo != null) {
                    lista = ConvenioActivo.getCuotasPendientes();
                } else
                    foreach (Deuda deuda in getDeudaInformada())
                        lista.Add(deuda);

                foreach (Deuda deuda in getDeudaNoInformada())
                    lista.Add(deuda);

                return lista;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve la fecha de la última deuda 'informada'. 
        /// Lanza DataErrorException si tiene algún problema.
        /// </summary>
        /// <returns>
        /// La lista de deudas informadas sin ordenar, o una lista vacia si no 
        /// hay nada. 
        /// </returns>
        public virtual DateTime getFechaUltimaDeudaInformada() {
            try {
                foreach (Deuda deuda in repos.Deudas.OrdenarPorFechaDesc(Deudas))
                    if (deuda.isAlive() && deuda.Informada)
                        return deuda.FechaAlta;

                return Fechas.FechaNull;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método aplica un pago a la cuenta, pero a una deuda determinada
        /// que es de la cuenta y se conoce. Lanza una DataErrorException si no 
        /// puede aplicar el pago porque la deuda no es de la cuenta.
        /// </summary>
        /// <param name="pago">
        /// El pago a aplicarse a la cuenta.
        /// </param>
        /// <param name="deuda">
        /// La deuda a la que debe aplicarse el pago.
        /// </param>
        /// <returns>
        /// El resto que queda una vez aplicado el pago (si queda algo).
        /// </returns> 
        public virtual double ingresarPago(Pago pago, Deuda deuda) {
            if (deuda == null || !Deudas.Contains(deuda))
                throw new DataErrorException("ERROR-PAGO-SINDEUDA");
            if (pago == null)
                throw new DataErrorException("ERROR-PAGO-TIPO");
            if (pago.getSaldo() <= 0)
                throw new DataErrorException("ERROR-PAGO-SINIMPORTE");
            if (!isAlive() || !Activada)
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", ToString());

            return deuda.aplicarPago(pago);
        }

        /// <summary>
        /// Este método obtiene el conjunto de pagos asociados a
        /// la cuenta, es decir a deudas perteneciente a la misma.
        /// </summary>
        /// <returns>
        /// Una lista de pagos asociados directamente a la cuenta
        /// sin ordenar, o una lista vacia si no hay nada. 
        /// </returns>
        public virtual IList<Pago> getPagos() {
            try {
                refrescar();

                IList<Pago> lista = new List<Pago>();
                foreach (Deuda deuda in Deudas)
                    foreach (Imputacion imp in deuda.Imputaciones)
                        if (imp.Pago != null && imp.Pago.isAlive())
                            lista.Add(imp.Pago);

                return lista;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método calcula el monto total pagado para la cuenta.
        /// </summary>
        /// <returns>
        /// El monto pagado total de la cuenta.
        /// </returns>
        public virtual double getMontoPagadoTotal() {
            try {
                double saldo = 0;
                foreach (Pago pago in getPagos())
                    saldo += pago.Total;
                return saldo;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método se utiliza para agregar una Gestion a la cuenta. 
        /// Si la gestión ya existe dentro de la cuenta, entonces no hace
        /// nada. Se lanza una DataErrorException si tiene problemas.
        /// </summary>
        /// <param name="gestion">
        /// La Gestion a agregarse para la cuenta.
        /// </param>
        public virtual void agregarGestion(Gestion gestion) {
            if (gestion == null || (gestion.Cuenta != null && !Equals(gestion.Cuenta)))
                throw new DataErrorException(
                    "ERROR-NOADD-ELEMENTO",
                    (gestion == null)
                        ? "GESTION"
                        : gestion.ToString());

            // Si es una gestion que vino desde la lista que tiene 
            // tomada la cuenta, entonces libera la cuenta de la misma
            if (gestion.Lista != null && ListaAsignada != null && gestion.Lista.Equals(ListaAsignada))
                ListaAsignada = null;

            // Si ya existe la gestion no hace nada
            if (Gestiones.Contains(gestion))
                return;

            try {
                gestion.Cuenta = this;
                Gestiones.Add(gestion);
                save();
            } catch (Exception e) {
                gestion.Cuenta = null;
                Gestiones.Remove(gestion);
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método obtiene el conjunto de gestiones activas
        /// de la cuenta.
        /// </summary>
        /// <returns>
        /// La lista de gestiones activas sin ordenar, o una lista 
        /// vacia si no hay nada. 
        /// </returns>
        public virtual IList<Gestion> getGestionesActivas() {
            IList<Gestion> lista = new List<Gestion>();

            foreach (Gestion gg in Gestiones)
                if (gg.isAlive() && !gg.estaFinalizada())
                    lista.Add(gg);

            return lista;
        }

        /// <summary>
        /// Este método obtiene el conjunto de gestiones raelizadas
        /// de la cuenta.
        /// </summary>
        /// <returns>
        /// La lista de gestiones activas sin ordenar, o una lista 
        /// vacia si no hay nada. 
        /// </returns>
        public virtual IList<Gestion> getGestionesRealizadas() {
            IList<Gestion> lista = new List<Gestion>();

            foreach (Gestion gg in Gestiones)
                if (gg.isAlive() && gg.estaFinalizada())
                    lista.Add(gg);

            return lista;
        }

        /// <summary>
        /// Este método obtiene la cantidad de gestiones realizadas
        /// de la cuenta.
        /// </summary>
        /// <returns>
        /// La lista de gestiones activas sin ordenar, o una lista 
        /// vacia si no hay nada. 
        /// </returns>
        public virtual long getCantidadGestionesRealizadas() {
            long cantidad = 0;

            foreach (Gestion gg in Gestiones)
                if (gg.isAlive() && gg.estaFinalizada())
                    cantidad++;

            return cantidad;
        }

        /// <summary>
        /// Este método obtiene la enésima gestion anterior, es decir la
        /// ultima menos n, donde n se pasa en el parámetro cuanAnterior.
        /// Solamente toma en cuenta las gestiones finalizadas y que no 
        /// estan bajadas.
        /// </summary>
        /// <param name="cuanAnterior">
        /// La cantidad de visitas hacia atrás de la ultima que se desea.
        /// </param>
        /// <returns>
        /// La visita deseada de acuerdo a cuan anterior se pide.
        /// </returns>
        public virtual Gestion getGestionRealizadaAnterior(int cuanAnterior) {
            if (cuanAnterior < 0 || cuanAnterior > Gestiones.Count)
                return null;

            int pos = 0;
            foreach (Gestion g in 
                gestion.repos.Gestiones.OrdenarPorFechaCierreDesc(getGestionesRealizadas()))
                if (cuanAnterior == pos++)
                    return g;

            return null;
        }

        /// <summary>
        /// Este método obtiene la enésima gestion anterior, es decir la
        /// ultima menos n, donde n se pasa en el parámetro cuanAnterior.
        /// Solamente toma en cuenta las gestiones finalizadas y que no 
        /// estan bajadas.
        /// Esta forma NO realiza Refresh de la base por lo que alguna de
        /// las gestiones podría no estar 100% actualizada.
        /// </summary>
        /// <param name="cuanAnterior">
        /// La cantidad de gestiones hacia atrás de la ultima que se desea.
        /// </param>
        /// <returns>
        /// La gestion deseada de acuerdo a cuan anterior se pide.
        /// </returns>
        public virtual Gestion getGestionRealizadaAnteriorSinRefresh(int cuanAnterior) {
            if (cuanAnterior < 0 || cuanAnterior > Gestiones.Count)
                return null;

            int pos = 0;
            foreach (Gestion g in gestion.repos.Gestiones.OrdenarPorFechaCierreDesc(Gestiones))
                if (g.isAlive() && g.Estado.Equals(_finalizada))
                    if (cuanAnterior == pos++)
                        return g;

            return null;
        }

        /// <summary>
        /// Este método se utiliza para agregar un convenio a la cuenta. 
        /// Se marca toda deuda activa como pisadas por nuevo convenio.
        /// Antes que nada debe verificar que no exista ya uno activo pq
        /// solo puede haber un activo por cuenta (hay que dar de baja el
        /// anterior antes de agergar). Se lanza una DataErrorException 
        /// si tiene algún problema.
        /// </summary>
        /// <param name="convenio">
        /// El convenio a agregarse para la cuenta.
        /// </param>
        public virtual void agregarConvenio(Convenio convenio) {
            if (convenio == null)
                throw new DataErrorException("ERROR-NOADD-ELEMENTO", "CONVENIO");
            if (!convenio.isAlive())
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", convenio.ToString());
            if (!isAlive())
                throw new DataErrorException("ERROR-USE-ELEMENTO-NOALIVE", ToString());
            if (!Equals(convenio.Cuenta))
                throw new DataErrorException("ERROR-NOADD-ELEMENTO", convenio.ToString());
            if (ConvenioActivo != null)
                throw new DataErrorException("ERROR-NOADD-ELEMENTO", Mensaje.TextoMensaje("ERROR-CONVENIO-NODUP"));

            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                // Marca la deuda de la cuenta como en convenio
                foreach (Deuda deuda in getDeudaInformada())
                    deuda.marcarDeudaEnConvenio(convenio);                

                // Ahora establece el convenio
                ConvenioActivo = convenio;

                // Modifica el estado de la cuenta
                string msj = "**CONVENIO FORMALIZADO** en Fecha:" + DateTime.Now.ToShortDateString();
                setearEstado((Estado.Clave.Contains("JUICIO") ? _juicioConve : _acuerdo), msj);

                save();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                refrescar();
                ConvenioActivo = null;
                foreach (Deuda deuda in getDeudaTotalActual())
                    deuda.refrescar();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método se utiliza para bajar el convenio activo de la cuenta. 
        /// Antes que nada verifica si existe uno, luego se lo baja y reaviva 
        /// toda la deuda informada asociada (que le dió origen). Tambien deja 
        /// a la cuenta en estado de cuenta con convenio caido. Puede lanzar una 
        /// DataErrorException si tiene algún problema.
        /// </summary>
        public virtual void bajarConvenioActivo() {
            if (ConvenioActivo == null)
                throw new DataErrorException("ERROR-CONVENIO-NOEXISTS");

            Convenio convenio = ConvenioActivo;
            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();
                ConvenioActivo.bajarConvenio();
                save();
                Persistencia.Controlador.commitTransaccion(scn);

                foreach (Deuda deuda in getDeudaEnConvenio()) {
                    deuda.quitarDeudaDeConvenio();
                    deuda.save();
                }
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                convenio.refrescar();
                throw new FatalErrorException("ERROR-CUENTA", e.ToString());
            } finally {
                refrescar();
                convenio.refrescar();
            }
        }

        /// <summary>
        /// Este método calcula la antiguedad de la deuda de la cuenta
        /// como la cantidad de días pasado desde la Fecha de la deuda
        /// origen activa actual. 
        /// </summary>
        /// <returns>
        /// La antiguedad de la deuda de la cuenta.
        /// </returns>
        public virtual long getAntiguedadDeuda() {
            long ant;
            foreach (Deuda dd in repos.Deudas.OrdenarPorFecha(getDeudaTotalActual()))
                return ((ant = (DateTime.Today - dd.FechaVencimiento.Date).Days) < 0) ? 0 : ant;
            return 0;
        }

        /// <summary>
        /// Este método calcula la antiguedad de la cuenta como la diferencia
        /// de dias desde la fehca de alta de la cuenta.
        /// </summary>
        /// <returns>
        /// La antiguedad de la cuenta.
        /// </returns>
        public virtual long getAntiguedadCuenta() {
            long ant = (DateTime.Today - FechaAsignacion.Date).Days;
            return (ant < 0) ? 0 : ant;
        }

        /// <summary>
        /// Este método calcula la antiguedad del ultimo pago de la cuenta
        /// como la cantidad de días pasado desde la Fecha de dicho pago.
        /// </summary>
        /// <returns>
        /// La antiguedad del ultimo pago de la cuenta.
        /// </returns>
        public virtual long getAntiguedadPago() {
            long ant = 0;
            foreach (Pago pago in repos.Pagos.OrdenarPorFecha(getPagos()))
                ant = (DateTime.Today - pago.Fecha.Date).Days;
            return (ant < 0) ? 0 : ant;
        }

        /// <summary>
        /// Este método devuelve el saldo de la cuenta como el: a) si hay convenio
        /// => el saldo del convenio + el saldo no informado; y b) si no hay convenio
        /// => el saldo informado + el saldo no informado; Siempre se toma el recargo. 
        /// </summary>
        /// <returns>
        /// El saldo de deuda origen activa actual de la cuenta.
        /// </returns>
        public virtual double getMontoSaldoTotalActual() {
            try {
                double saldo = 0;
                foreach (Deuda cta in getDeudaTotalActual())
                    saldo += cta.Total;
                return saldo;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve el Saldo que corresponde a la deuda 
        /// actual informada de la cuenta. 
        /// </summary>
        /// <returns>
        /// El monto para el saldo informado actual de la cuenta.
        /// </returns>
        public virtual double getMontoSaldoDeudaInformada() {
            try {
                double saldo = 0;
                foreach (Deuda cta in getDeudaInformada())
                    saldo += cta.Total;
                return saldo;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve el Saldo que corresponde a la deuda 
        /// actual no informada de la cuenta. 
        /// </summary>
        /// <returns>
        /// El monto para el saldo no informado actual de la cuenta.
        /// </returns>
        public virtual double getMontoSaldoDeudaNoInformada() {
            try {
                double saldo = 0;
                foreach (Deuda cta in getDeudaNoInformada())
                    saldo += cta.Total;
                return saldo;
            } catch (Exception e) {
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Este método devuelve el Saldo que corresponde a la deuda 
        /// actual de convenio de la cuenta (del convenio activo). 
        /// </summary>
        /// <returns>
        /// El monto para el saldo de convenio actual de la cuenta.
        /// </returns>
        public virtual double getMontoSaldoConvenio() {
            return (ConvenioActivo != null)
                       ? ConvenioActivo.getMontoSaldoTotalActual()
                       : 0;
        }

        /// <summary>
        /// Este método retorna el tramo en el que actualmente se encuentra
        /// la cuenta (dada su antiguedad ó ctdad de gestiones y la config.
        /// hecha en el Producto al que pertenece la cuenta).
        /// </summary>
        /// <returns></returns>
        public virtual Tramo getTramo() {
            return Producto.getTramoCorrespondiente(this);            
        }

        /// <summary>
        ///   Este método verifica si el convenio tiene algo de deuda 
        ///   y, si no es así, entonces lo cancela.
        /// </summary>
        /// <returns>
        ///   Devuelve 'true' si el convenio debe caer o false si no. 
        /// </returns>
        public virtual void verificarYCancelarReavivar() {
            if (getMontoSaldoTotalActual() <= 0)
                cancelarCuenta();
            else 
                descancelarCuenta();
        }

        /// <summary>
        ///   Este método ejecuta la cancelación de una cuenta, colocando
        ///   el estado de cancelacion total de deuda y agregando un comentario
        ///   en el historial de estados.
        /// </summary>
        public virtual void cancelarCuenta() {
            if (Estado != _cancelada) {
                setearEstado(_cancelada);
                Activada = false;
                save();
            }
        }

        /// <summary>
        ///   Este método ejecuta la descancelación de una cuenta, verificando
        ///   que si la misma tiene el estado cancelado, entonces lo saca y la 
        ///   vuelve al estado inmediato anterior según el historial de estados 
        ///   ó a estado "en gestion" si no tiene historial.
        /// </summary>
        public virtual void descancelarCuenta() {
            if (Estado == _cancelada) {
                Activada = true;

                EstadoCuenta estado = getEnesimoEstadoCuenta(1);
                Parametro est = (ConvenioActivo != null && estado != null) ? estado.Estado : _gestion;

                setearEstado(est, "Cuenta reactivada en fecha:" + DateTime.Now.ToShortDateString());
                save();
            }
        }

        /// <summary>
        /// Ver descripción en clase base. En este caso al deletearse
        /// la cuenta, primero se elimina del producto y la entidad. 
        /// Puede lanzar una DataErrorException si tiene problemas.
        /// </summary>
        public override void delete() {
            if (!isAlive())
                return;

            try {
                Producto = null;
                Entidad = null;
                Activada = false;
                Descripcion += string.Format(
                                    " **DADA DE BAJA** en fecha {0} por {1}",
                                    DateTime.Now,
                                    Sistema.Controlador.SecurityService.getUsuario().Nombre);
                if (ConvenioActivo != null)
                    ConvenioActivo.bajarConvenio();
                base.delete();
            } catch (Exception e) {
                refrescar();
                undelete();
                throw new DataErrorException("ERROR-CUENTA", e.ToString());
            }
        }

        /// <summary>
        /// Para poder utilizarlo en la instrucción Using.
        /// </summary>
        public virtual void Dispose() {}

        /// <summary>
        /// Este método genera el string por defecto a mostrar en todos lados.
        /// </summary>
        public override string ToString() {
            return string.Format("{0} ({1})", Codigo, Titular);
        }
    }
}