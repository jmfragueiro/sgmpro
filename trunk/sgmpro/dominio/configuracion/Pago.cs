///////////////////////////////////////////////////////////
//  Pago.cs
//  Implementation of the Class Pago
//  Generated by Enterprise Architect
//  Created on:      13-May-2009 03:54:59 p.m.
//  Original author: Fernando
///////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;
using scioBaseLibrary;
using scioBaseLibrary.excepciones;
using scioParamLibrary.dominio;
using scioParamLibrary.dominio.repos;
using scioPersistentLibrary;
using scioPersistentLibrary.acceso;
using scioToolLibrary;

namespace sgmpro.dominio.configuracion {
    /// <summary>
    ///   Esta clase representa a un Pago asociada a una Deuda de una Cuenta morosa dentro 
    ///   del sistema. La Deuda puede ser tanto la que se asocia directamente (por ejem vía 
    ///   cuotas de deuda inicial o importes de gastos que se agregan por x motivo), como a 
    ///   la que se asocia a partir de un Convenio de refinaciación firmado, el cual genera
    ///   tantas entradas en Deuda como cuotas tenga. Un Pago puede estar asociado a varias
    ///   Deudas a partir de la Imputación sobre estas que se haga, de esta forma es posible
    ///   pagar, por ejem, varias cuotas de un Convenio con un solo pago, el cual se imputa
    ///   a cada una en una parte. Un pago no se mata sino es a través de una anulación, lo 
    ///   que elimina las imputaciones que este posea y da de baja los recibos asociados. Un
    ///   pago no puede 'reavivarse'. Esta clase es persistente.
    /// </summary>
    public class Pago : EntidadIdentificada<Pago> {
        private readonly Parametro _pendiente = Parametros.GetByClave("ESTADOPAGO.PENDIENTE");
        private readonly Parametro _parcial = Parametros.GetByClave("ESTADOPAGO.PARCIAL");
        private readonly Parametro _aplicado = Parametros.GetByClave("ESTADOPAGO.APLICADO");
        private readonly Parametro _anulado = Parametros.GetByClave("ESTADOPAGO.ANULADO");
        private readonly double _iva = Math.Round((Parametros.GetByClave("GESTION.IVA").Valordouble/100), 2);

        /// <summary>
        ///   La fecha formal (de vencimiento) asociada al pago. No Nulo.
        /// </summary>
        public virtual DateTime Fecha {
            get { return _fecha; }
            set { _fecha = Fechas.GetOkDate(value); }
        }
        private DateTime _fecha = Fechas.FechaNull;
        /// <summary>
        ///   El concepto del pago de cuenta corriente. Parámetro. No Nulo. FK.
        /// </summary>
        public virtual Parametro Tipo { get; set; }
        /// <summary>
        ///   El estado del pago. No Nulo.
        /// </summary>
        public virtual Parametro Estado { get; set; }
        /// <summary>
        ///   Una descripción asociada al pago.
        /// </summary>
        public virtual string Descripcion { get; set; }
        /// <summary>
        ///   El recibo de pago en caso de existir. No Nulo.
        /// </summary>
        public virtual string Recibo {
            get { 
                foreach (var recibo in Recibos) 
                    if (recibo.isAlive()) 
                        return recibo.ToString();
                return string.Empty; 
            }
        }
        /// <summary>
        ///   El importe total de pago. No Nulo.
        /// </summary>
        public virtual double Total {
            get { return Math.Round((_capital + _interes + _honorarios + _gastos), 2); }
        }
        /// <summary>
        ///   El importe de capital de pago. No Nulo.
        /// </summary>
        public virtual double Capital {
            get { return _capital; }
            set { _capital = Math.Round(value, 2); }
        }
        private double _capital;
        /// <summary>
        ///   El importe de intereses de pago. No Nulo.
        /// </summary>
        public virtual double Interes {
            get { return _interes; }
            set { _interes = Math.Round(value, 2); }
        }
        private double _interes;
        /// <summary>
        ///   El importe de honorarios de pago. No Nulo.
        /// </summary>
        public virtual double Honorarios {
            get { return _honorarios; }
            set { _honorarios = Math.Round(value, 2); }
        }
        private double _honorarios;
        /// <summary>
        ///   El importe de gastos de pago. No Nulo.
        /// </summary>
        public virtual double Gastos {
            get { return _gastos; }
            set { _gastos = Math.Round(value, 2); }
        }
        private double _gastos;
        /// <summary>
        ///   La forma de pago en caso de corresponder. Parámetro.
        /// </summary>
        public virtual Parametro FormaPago { get; set; }
        /// <summary>
        ///   La cuenta del pago (puede imputarse a varias deudas pero de una cuenta). FK.
        /// </summary>
        public virtual Cuenta Cuenta { get; set; }
        /// <summary>
        ///   La fecha de alta del pago. No Nulo.
        /// </summary>
        public virtual DateTime FechaUMod {
            get { return _fechaumod; }
            set { _fechaumod = Fechas.GetOkDate(value); }
        }
        private DateTime _fechaumod = DateTime.Now;
        /// <summary>
        ///   Conjunto de imputaciones a deudas asociadas al pago. FK (Bag).
        /// </summary>
        public virtual IList<Imputacion> Imputaciones { get; set; }
        /// <summary>
        ///   Conjunto de recibos asociados al pago. FK (Bag).
        /// </summary>
        public virtual IList<Recibo> Recibos { get; set; }

        /// <summary>
        ///   Constructor que instancia los conjuntos de la clase.
        /// </summary>
        public Pago() {
            Imputaciones = new List<Imputacion>();
            Recibos = new List<Recibo>();
        }

        /// <summary>
        ///   Este método calcula el saldo total de un pago, es decir la ctdad
        ///   de dinero del pago que todavía no se ha imputado a deuda alguna.
        ///   No se capturan excepciones.
        /// </summary>
        /// <returns>
        ///   El saldo total del pago (referido a sus imputaciones).
        /// </returns>
        public virtual double getSaldo() {
            return Math.Round((getSaldoCapital() 
                        + getSaldoInteres() 
                        + getSaldoHonorario() 
                        + getSaldoGastos()), 2);
        }

        /// <summary>
        ///   Este método calcula el saldo de capital de un pago, es decir la ctdad
        ///   de dinero de capital del pago que no se ha imputado a deuda alguna. No
        ///   se capturan excepciones.
        /// </summary>
        /// <returns>
        ///   El saldo de capital del pago (referido a sus imputaciones).
        /// </returns>
        public virtual double getSaldoCapital() {
            Double importe = Capital;

            foreach (Imputacion imp in Imputaciones)
                importe -= imp.Capital;

            return (importe < 0) ? 0 : importe;
        }

        /// <summary>
        ///   Este método calcula lo Imputado de capital de un pago. No captura excepciones.
        /// </summary>
        /// <returns>
        ///   Lo Imputado de capital de un pago.
        /// </returns>
        public virtual double getImputadoCapital() {
            return (Capital - getSaldoCapital());
        }

        /// <summary>
        ///   Este método calcula el saldo de interes de un pago, es decir la ctdad
        ///   de dinero de interes del pago que no se ha imputado a deuda alguna. No
        ///   se capturan excepciones.
        /// </summary>
        /// <returns>
        ///   El saldo de interes del pago (referido a sus imputaciones).
        /// </returns>
        public virtual double getSaldoInteres() {
            Double importe = Interes;

            foreach (Imputacion imp in Imputaciones)
                importe -= imp.Interes;

            return (importe < 0) ? 0 : importe;
        }

        /// <summary>
        ///   Este método calcula lo Imputado de Interes de un pago. No captura excepciones.
        /// </summary>
        /// <returns>
        ///   Lo Imputado de Interes de un pago.
        /// </returns>
        public virtual double getImputadoInteres() {
            return (Interes - getSaldoInteres());
        }

        /// <summary>
        ///   Este método calcula el saldo de honorarios de un pago, es decir la ctdad
        ///   de dinero de honorarios del pago que no se ha imputado a deuda alguna. Se
        ///   controla el tema del IVA, es decir que si el saldo de honorario es menor o 
        ///   igual al porcentaje de iva definido en la aplicación, entonces devuelve 0.
        ///   No se capturan excepciones.
        /// </summary>
        /// <returns>
        ///   El saldo de honorarios del pago (referido a sus imputaciones).
        /// </returns>
        public virtual double getSaldoHonorario() {
            Double importe = Honorarios;

            foreach (Imputacion imp in Imputaciones)
                importe -= imp.Honorarios;

            /////////////////////////////////////////////////////
            // Es porque se agrego el tema del pago de IVA
            /////////////////////////////////////////////////////
            return (importe <= (Honorarios * _iva)) ? 0 : importe;
            /////////////////////////////////////////////////////
        }

        /// <summary>
        ///   Este método calcula lo Imputado de honorarios de un pago. No captura excepciones.
        /// </summary>
        /// <returns>
        ///   Lo Imputado de honorarios de un pago.
        /// </returns>
        public virtual double getImputadoHonorarios() {
            double pagado = Honorarios - getSaldoHonorario();
            return (pagado < 0) ? 0 : pagado;
        }

        /// <summary>
        ///   Este método calcula el saldo de gastos de un pago, es decir la ctdad
        ///   de dinero de gastos del pago que no se ha imputado a deuda alguna. No
        ///   se capturan excepciones.
        /// </summary>
        /// <returns>
        ///   El saldo de gastos del pago (referido a sus imputaciones).
        /// </returns>
        public virtual double getSaldoGastos() {
            Double importe = Gastos;

            foreach (Imputacion imp in Imputaciones)
                importe -= imp.Gastos;

            return (importe < 0) ? 0 : importe;
        }

        /// <summary>
        ///   Este método calcula lo Imputado de gastos de un pago. No captura excepciones.
        /// </summary>
        /// <returns>
        ///   Lo Imputado de gastos de un pago.
        /// </returns>
        public virtual double getImputadoGastos() {
            return (Gastos - getSaldoGastos());
        }

        /// <summary>
        ///   Este método resetea el estado de la deuda recalculando para
        ///   ver cuál es el correcto entre PENDIENTE, PARCIAL ó APLICADO.
        ///   No se persisten los cambios. No se capturan excepciones.
        /// </summary>
        public virtual void resetEstado() {
            Double saldo = getSaldo();
            Estado = (saldo > 0)
                         ? ((saldo == Total) ? _pendiente : _parcial)
                         : _aplicado;
        }

        /// <summary>
        ///   Este método genera un objeto pago a partir de transformar otro de
        ///   origen pero cambiando el tipo de pago y los montos del mismo. Es 
        ///   decir que se 'transforma' de alguna manera el pago de origen. No 
        ///   hace persistir el pago generado.
        /// </summary>
        /// <param name = "tipo">
        ///   El tipo de pago para el pago generado.
        /// </param>
        /// <param name = "monto">
        ///   Un arreglo con lo montos a aplicarse como: cap, int, hon, gas.
        /// </param>
        /// <returns>
        ///   El pago generado (sin persistir).
        /// </returns>
        public virtual Pago transformarPago(Parametro tipo, params double[] monto) {
            return new Pago {
                Fecha = Fecha,
                Tipo = tipo,
                Estado = Estado,
                Descripcion = Descripcion,
                FormaPago = FormaPago,
                Capital = monto[0],
                Interes = monto[1],
                Honorarios = monto[2],
                Gastos = monto[3],
                Cuenta = Cuenta,
                FechaUMod = FechaUMod,
                FechaBaja = Fechas.FechaNull
            };
        }

        /// <summary>
        ///   Ver descripción en clase base. En este caso al deletearse el
        ///   pago primero se revierte (por lo que se desimputará de toda 
        ///   deuda que lo tiene asociado) y luego se deletean los recibos
        ///   agregando una marca de anulado a los mismos. Finalmente cambia 
        ///   su estado a anulado y lo baja. Lanza una DataErrorException si 
        ///   tiene problemas.
        /// </summary>
        public override void delete() {
            if (!isAlive() || Estado.Equals(_anulado))
                return;

            Convenio convenio = null;
            IList<Recibo> recs = new List<Recibo>();
            IList<Imputacion> imps = new List<Imputacion>();      
      
            try {
                long scn = Persistencia.Controlador.iniciarTransaccion();

                foreach (Imputacion imputacion in Imputaciones) {
                    convenio = convenio ?? imputacion.Deuda.Convenio; 
                    imps.Add(imputacion);
                }
                foreach (Imputacion imputacion in imps)
                    imputacion.delete();

                string rec = !String.IsNullOrEmpty(Recibo) ? " (" + Recibo + ")" : string.Empty;

                foreach (Recibo recibo in Recibos) 
                    recs.Add(recibo);
                foreach (Recibo recibo in recs) 
                    recibo.delete();
                

                Estado = _anulado;
                Descripcion += string.Format(
                    " **ANULADA** en fecha {0} por {1}{2}",
                                    DateTime.Now,
                                    Sistema.Controlador.SecurityService.getUsuario().Nombre, rec);
                base.delete();
                Persistencia.Controlador.commitTransaccion(scn);
            } catch (Exception e) {
                Persistencia.Controlador.rollbackTransaccion();
                foreach (Imputacion imputacion in imps)
                    imputacion.refrescar();
                foreach (Recibo recibo in recs)
                    recibo.refrescar();
                refrescar();
                throw new DataErrorException("ERROR-PAGO", e.ToString());
            }

            try {
                // Aqui verifica si la cuenta (o en todos caso el convenio apuntado por 
                // alguna deuda) tiene un estado cancelado, en cuyo caso la "descancela"
                if (convenio != null)
                    convenio.verificarYCancelarReavivar();                    
                Cuenta.verificarYCancelarReavivar();
            } catch (Exception e) {
                throw new DataErrorException("ERROR-POSANULAPAGO-PAGO", e.ToString());
            }
        }

        /// <summary>
        ///   Este método evita que se desborre (o reavive) un pago.
        /// </summary>
        public override void undelete() {
            throw new DataErrorException("DATA-UNDEL-NOK");
        }

        /// <summary>
        ///   Este método genera el string por defecto a mostrar en todos lados.
        /// </summary>
        public override string ToString() {
            return string.Format("[{0}]={1:C}", Tipo, Total);
        }
    }
}